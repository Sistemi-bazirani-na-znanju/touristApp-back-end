package authRules

import tourstApp.model.Reservation;
import tourstApp.model.Excursion;
import tourstApp.model.ExcursionType;
import tourstApp.model.Rating;
import tourstApp.model.User;
import tourstApp.model.Arrangement;
import tourstApp.model.RatingType;
import tourstApp.service.ArrangementService;
import tourstApp.util.Doubble;
import java.util.List;
import java.util.ArrayList;
import java.time.LocalDateTime;
import java.util.Random;

rule "Check if User is New or Not"
no-loop true
when
    // Pattern to match User objects and extract the 'ratings' property
    $user: User($ratings: ratings, $isNew: isNew)
    // Evaluation condition to check the number of ratings
    eval($ratings.size() >= 3)
then
    // Modify the 'isNew' property to false if the user has 3 or more ratings
    System.out.println("Executing rule: Check if User is New or Not");
    modify($user) {
        setNew(false)
    };
end

rule "Check if User is New"
when
    // Pattern to match User objects and extract the 'ratings' property
    $user: User($ratings: ratings, $isNew: isNew)
    // Evaluation condition to check if the user has less than 3 ratings
    eval($ratings.size() < 3)
then
    // Modify the 'isNew' property to true if the user has less than 3 ratings
    System.out.println("Executing rule: Check if User is New");
    modify($user) {
        setNew(true)
    };
end


rule "Check User Recommendation Based on Pearson Similarity"
when
    // Match a user who is not new
    $user: User(isNew == false, $userRatings: ratings)
    // Match other users to compare with
    $otherUser: User(this != $user, $otherUserRatings: ratings)
then
    // Initialize variables for Pearson correlation calculation
    double pearsonCorrelation = 0.0;
    double sumRaRu = 0.0;
    double sumRaSquared = 0.0;
    double sumRuSquared = 0.0;

    // Filter ratings to include only the ratings of arrangements they both rated
    List<Rating> filteredUserRatings = new ArrayList<>();
    List<Rating> filteredOtherUserRatings = new ArrayList<>();

    // Iterate through the ratings to filter for common arrangements
    for (Rating userRating : $userRatings) {
        for (Rating otherUserRating : $otherUserRatings) {
            if (userRating.getArrangement().getId().equals(otherUserRating.getArrangement().getId())) {
                filteredUserRatings.add(userRating);
                filteredOtherUserRatings.add(otherUserRating);
            }
        }
    }

    // Check if there is any common arrangement rated by both users
    if (!filteredUserRatings.isEmpty()) {
        // Calculate mean ratings for user and other user based on filtered ratings
        double meanUserRating = filteredUserRatings.stream().mapToDouble(Rating::getRatingValue).average().orElse(0.0);
        double meanOtherUserRating = filteredOtherUserRatings.stream().mapToDouble(Rating::getRatingValue).average().orElse(0.0);

        // Iterate through filtered ratings and calculate components of Pearson correlation
        for (int i = 0; i < filteredUserRatings.size(); i++) {
            Rating userRating = filteredUserRatings.get(i);
            Rating otherUserRating = filteredOtherUserRatings.get(i);
            double rai = userRating.getRatingValue();
            double rui = otherUserRating.getRatingValue();

            sumRaRu += (rai - meanUserRating) * (rui - meanOtherUserRating);
            sumRaSquared += Math.pow((rai - meanUserRating), 2);
            sumRuSquared += Math.pow((rui - meanOtherUserRating), 2);
        }

        // Calculate the Pearson correlation
        pearsonCorrelation = sumRaRu / (Math.sqrt(sumRaSquared) * Math.sqrt(sumRuSquared));

        // Check if correlation is greater than 0.5 and the user's rating for the arrangement is greater than 3
        for (int i = 0; i < filteredUserRatings.size(); i++) {
            Rating userRating = filteredUserRatings.get(i);
            if (pearsonCorrelation > 0.5 && userRating.getRatingValue() > 3) {
                Arrangement arrangement = userRating.getArrangement();
                // Set the arrangement as recommended
                modify(arrangement) {
                    setIsRecommended(true);
                };
            }
        }
    }
end

rule "Mark Arrangement as Recommended Based on Similar Arrangements"
when
    // Match a user who has rated at least one arrangement above 3
    $user: User($userRatings: ratings) from (User ratings.size() > 0 && userRatings.stream().anyMatch(r -> r.getRatingValue() > 3))
    // Match an arrangement that the user has not yet rated
    $arrangement: Arrangement(isRecommended == false)
then
    // Initialize variables for similarity calculation
    int totalComparisons = 0;
    int similarComparisons = 0;

    // Iterate through user ratings and check similarity with the current arrangement
    for (Rating userRating : $userRatings) {
        if (userRating.getRatingValue() <= 3) {
            // Skip ratings less than or equal to 3
            continue;
        }
        Arrangement ratedArrangement = userRating.getArrangement();

        // Calculate similarity between rated arrangement and current arrangement
        int similarRatings = 0;
        int totalRatings = 0;

        for (Rating raRating : ratedArrangement.getRatings()) {
            for (Rating arrRating : $arrangement.getRatings()) {
                // Check if users are the same and ratings are similar (same value or one value difference)
                if (raRating.getUser().equals(arrRating.getUser()) && Math.abs(raRating.getRatingValue() - arrRating.getRatingValue()) <= 1) {
                    similarRatings++;
                }
                totalRatings++;
            }
        }

        // Update similarity counters
        if (totalRatings > 0 && ((similarRatings / (double) totalRatings) * 100 >= 70)) {
            similarComparisons++;
        }
        totalComparisons++;
    }

    // Check if similarity condition is met
    if (totalComparisons > 0 && (similarComparisons / (double) totalComparisons) * 100 >= 70) {
        // If similarity condition is met, mark the arrangement as recommended
        modify($arrangement) {
            setIsRecommended(true)
        };
    }
end


rule "Mark Arrangement as Recommended Based on Destination and Excursion Type"
when
    // Match a user
    $user: User()
    // Match an arrangement that is not yet recommended
    $arrangement: Arrangement(isRecommended == false, $destination: destination, $excursions: excursions)
    $yearAgo: LocalDateTime() from (java.time.LocalDateTime.now().minusMonths(12))
then
    // Calculate one year ago from today


    // Check if user had reservations for arrangements with the same destination at least 2 times in the last year
    int destinationReservationCount = 0;
    for (Reservation reservation : $user.getReservations()) {
        Arrangement reservedArrangement = reservation.getArrangement();
        if (reservedArrangement.getDestination().equals($destination) &&
            reservation.getDate().isAfter(yearAgo)) {
            destinationReservationCount++;
        }
    }

    // If the user had at least 2 reservations with the same destination in the last year, mark the arrangement as recommended
    if (destinationReservationCount >= 2) {
        modify($arrangement) {
            setIsRecommended(true)
        };
    } else {
    // Calculate the percentage of similar excursion types the user has attended in the last year
    int similarExcursionCount = 0;
    int totalExcursions = 0;

    // Iterate through user's reservations
    for (Reservation reservation : $user.getReservations()) {
        // Ensure the reservation date is within the last year
        if (reservation.getDate().isAfter(yearAgo)) {
            // Get the chosen excursions from the reservation
            List<Excursion> chosenExcursions = reservation.getChosenExcursions();

            // Iterate through each chosen excursion
            for (Excursion chosenExcursion : chosenExcursions) {
                totalExcursions++;

                // Check if the excursion type matches the arrangement's excursions' type
                if ($excursions.contains(chosenExcursion.getExcursionType())) {
                    similarExcursionCount++;
                }
            }
        }
    }

    // Calculate the percentage of similar excursions
    if (totalExcursions > 0) {
        double percentageSimilar = (double) similarExcursionCount / totalExcursions;

        // If the percentage is at least 40%, mark the arrangement as recommended
        if (percentageSimilar >= 0.4) {
            modify($arrangement) {
                setIsRecommended(true)
            };
        }
    }
}
end