package authRules

import tourstApp.model.Reservation;
import tourstApp.model.Excursion;
import tourstApp.model.ExcursionType;
import tourstApp.model.Rating;
import tourstApp.model.Arrangement;
import tourstApp.model.RatingType;
import tourstApp.model.User;
import tourstApp.service.ArrangementService;
import tourstApp.util.Doubble;
import tourstApp.util.UserDrl;
import tourstApp.util.RatingDrl;
import java.util.List;
import java.util.ArrayList;
import java.time.LocalDateTime;
import java.util.Random;
import java.lang.Long;
import java.util.Comparator;
import java.util.stream.Collectors;

// rule "Check if User is New or Not"
// salience 10
// when
//     // Pattern to match User objects and extract the 'ratings' property
//     $user: UserDrl($isNew: isNew)   

//     $ratings: List() from collect(Rating())
//     // Evaluation condition to check the number of ratings
//     eval($ratings.size() >= 3)
// then
//     // Modify the 'isNew' property to false if the user has 3 or more ratings
//     modify($user) {
//         setIsNew(false)
//     };
//     System.out.println("poludecu jos vise");
// end

// rule "Check if User is New"
// salience 9
// when
//     $user: UserDrl($isNew: isNew)   

//     $ratings: List() from collect(Rating())
//     // Evaluation condition to check the number of ratings
//     eval($ratings.size() < 3)
// then
//     // Modify the 'isNew' property to true if the user has less than 3 ratings
//     modify($user) {
//         setIsNew(true)
//     };
//     System.out.println("poludecu");
// end


// rule "Check User Recommendation Based on Pearson Similarity"
// when
//     // Get a list of other users and an arrangement
//     $userId: Long()
//     $user: UserDrl(id == $userId)
//     $otherUsers: List() from collect(UserDrl(id != $userId))

//     $userRatings: List() from collect(RatingDrl(userId == $userId))
//     $otherUserRatings: List() from collect(RatingDrl(userId != $userId))
//     $arrangements: List() from collect(Arrangement())

// then
//     // Iterate through the other users
//     for  (Object otherUser : $otherUsers) {
//         // Retrieve other user's ratings
//         List<RatingDrl> otherUserRatings = new ArrayList<>();
        
//         // Initialize variables for Pearson correlation calculation
//         double pearsonCorrelation = 0.0;
//         double sumRaRu = 0.0;
//         double sumRaSquared = 0.0;
//         double sumRuSquared = 0.0;
        
//         List<RatingDrl> userRatingsForArrangement = new ArrayList<>();
//         List<RatingDrl> otherUserRatingsForArrangement = new ArrayList<>();

//         for (Object userRating : $userRatings) {
//             RatingDrl rating = (RatingDrl) userRating;
//             if (rating.getArrangementId().equals($arrangement.getId())) {
//                 userRatingsForArrangement.add(rating);
//             }
//         }

        // Initialize variables for filtered ratings
        // $userRatingsForArrangement: List()
        // $otherUserRatingsForArrangement: List()
        // Rating userRatingForArrangement = null;
        // Rating otherUserRatingForArrangement = null;

        // Iterate through the ratings to find common ratings for the arrangement
        // for (Rating userRating : $userRatings) {
        //     if (userRating.getArrangement().equals($arrangement)) {
        //         userRatingForArrangement = userRating;
        //         break;
        //     }
        // }

        // if (userRatingForArrangement != null) {
        //     for (Rating otherUserRating : otherUserRatings) {
        //         if (otherUserRating.getArrangement().equals($arrangement)) {
        //             otherUserRatingForArrangement = otherUserRating;
        //             break;
        //         }
        //     }

        //     // If both users have rated the arrangement
        //     if (otherUserRatingForArrangement != null) {
        //         // Calculate mean ratings for the arrangement
        //         double meanUserRating = $userRatings.stream()
        //             .filter(r -> r.getArrangement().equals($arrangement))
        //             .mapToDouble(Rating::getRatingValue)
        //             .average().orElse(0.0);
                
        //         double meanOtherUserRating = otherUserRatings.stream()
        //             .filter(r -> r.getArrangement().equals($arrangement))
        //             .mapToDouble(Rating::getRatingValue)
        //             .average().orElse(0.0);

        //         // Calculate components of Pearson correlation
        //         double rai = userRatingForArrangement.getRatingValue();
        //         double rui = otherUserRatingForArrangement.getRatingValue();

        //         sumRaRu += (rai - meanUserRating) * (rui - meanOtherUserRating);
        //         sumRaSquared += Math.pow((rai - meanUserRating), 2);
        //         sumRuSquared += Math.pow((rui - meanOtherUserRating), 2);

        //         // Calculate the Pearson correlation
        //         if (sumRaSquared > 0 && sumRuSquared > 0) {
        //             pearsonCorrelation = sumRaRu / (Math.sqrt(sumRaSquared) * Math.sqrt(sumRuSquared));
        //         }

        //         // Check if correlation is greater than 0.5 and user's rating for arrangement is greater than 3
        //         if (pearsonCorrelation > 0.5 && rai > 3) {
        //             // Set the arrangement as recommended
        //             modify($arrangement) {
        //                 setRecommendedPoints(getRecommendedPoints() + 1)
        //             };
        //             break;
//         }
//     }
// }
//     }
// end


rule "Mark Arrangement as Recommended Based on Similar Arrangements"
when
    // $arrangement: Arrangement($arrangementId : id)
    $userId: Long() // The user ID
    $user: UserDrl(id == $userId) // The current user as UserDrl
    $userRatings: List() from collect(RatingDrl(userId == $userId, ratingValue > 3)) // The current user's positive ratings
    $newArrangement: Arrangement() // The arrangement being considered for insertion
    $allArrangements: List() from collect(Arrangement(id != $newArrangement.id)) // All other arrangements

then
    // Initialize variables for similarity calculation

    List<Arrangement> matchedArrangements = new ArrayList<>();

    if(!$allArrangements.isEmpty()) {

        for (Object arrangement : $allArrangements) {
            Arrangement arrangementClass = (Arrangement) arrangement;
            // Iterate through each rating in the arrangement
            for (Rating rating : arrangementClass.getRatings()) {
                // Check if the rating ID matches any userRating ID
                for (Object userRating : $userRatings) {
                    RatingDrl userRatingDrl = (RatingDrl) userRating;
                    if (rating.getId().equals(userRatingDrl.getId())) {
                        // Add the matching rating to the list
                        matchedArrangements.add(arrangementClass);
                        // Break the inner loop to avoid adding duplicate ratings
                        break;
                    }
                }
            }
        }


        int totalComparisons = 0;
        int similarComparisons = 0;

        if(matchedArrangements.size() > 0) {
        
            Rating userRating = null;

            // Iterate through each rating in the arrangement
            for (Rating rating : $newArrangement.getRatings()) {
                // Check if the rating's userId matches the specified userId
                RatingDrl ratingDrl = new RatingDrl(rating);
                if (ratingDrl.getUserId().equals($userId)) {
                    // Assign the rating to userRating
                    userRating = rating;
                    // Once a matching rating is found, exit the loop
                    break;
                }
            }

            if(userRating != null){

                for (Arrangement matchedArrangement : matchedArrangements) {
                        for(Rating rating : matchedArrangement.getRatings()){
                            if (Math.abs(rating.getRatingValue() - userRating.getRatingValue()) <= 1) {
                                    // If condition is met, mark the arrangement as recommended
                                    similarComparisons++;
                            }
                            totalComparisons++;
                        }
                }
            }
        }

        if (totalComparisons > 0 && (similarComparisons / (double) totalComparisons) * 100 >= 70) {
            // If similarity condition is met, mark the arrangement as recommended
            modify($newArrangement) {
                setRecommended(true)
            };

            int incrementedPoint = $newArrangement.getRecommendationPoints() + 1;
            modify($newArrangement){
                setRecommendationPoints(incrementedPoint)
            };
            // setRecommendationPoints(getRecommendedPoints() + 1);
        }
    }

    
end



// rule "Mark Arrangement as Recommended Based on Destination and Excursion Type"
// when
//     // Match a user
//     $user: User()
//     // Match an arrangement that is not yet recommended
//     $arrangement: Arrangement(isRecommended == false, $destination: destination, $excursions: excursions)
//     $yearAgo: LocalDateTime() from (java.time.LocalDateTime.now().minusMonths(12))
// then
//     // Check if user had reservations for arrangements with the same destination at least 2 times in the last year
//     int destinationReservationCount = 0;
//     for (Reservation reservation : $user.getReservations()) {
//         Arrangement reservedArrangement = reservation.getArrangement();
//         if (reservedArrangement.getDestination().getId().equals($destination.getId()) &&
//             reservation.getDate().isAfter(yearAgo)) {
//             destinationReservationCount++;
//         }
//     }
    
//     // If the user had at least 2 reservations with the same destination in the last year, mark the arrangement as recommended
//     if (destinationReservationCount >= 2) {
//         modify($arrangement) {
//             setRecommendedPoints(getRecommendedPoints() + 1)
//         };
//     } else {
//     // Calculate the percentage of similar excursion types the user has attended in the last year
//     int similarExcursionCount = 0;
//     int totalExcursions = 0;
    
//     // Iterate through user's reservations
//     for (Reservation reservation : $user.getReservations()) {
//         // Ensure the reservation date is within the last year
//         if (reservation.getDate().isAfter(yearAgo)) {
//             // Get the chosen excursions from the reservation
//             List<Excursion> chosenExcursions = reservation.getChosenExcursions();
            
//             // Iterate through each chosen excursion
//             for (Excursion chosenExcursion : chosenExcursions) {
//                 totalExcursions++;
                
//                 // Check if the excursion type matches the arrangement's excursions' type
//                 if ($excursions.contains(chosenExcursion.getExcursionType())) {
//                     similarExcursionCount++;
//                 }
//             }
//         }
//     }
    
//     // Calculate the percentage of similar excursions
//     if (totalExcursions > 0) {
//         double percentageSimilar = (double) similarExcursionCount / totalExcursions;
        
//         // If the percentage is at least 40%, mark the arrangement as recommended
//         if (percentageSimilar >= 0.4) {
//             modify($arrangement) {
//                 setRecommendedPoints(getRecommendedPoints() + 1)
//             };
//         }
//     }
// }
// end


rule "Trim isRecommended Arrangements to Top 20"
salience -100
when
    // Match a list of isRecommended arrangements
    $isRecommendedArrangements: List() from collect(
        Arrangement(
            Recommended == true
        )
    )
then
    // Check if there are more than 20 isRecommended arrangements
    if ($isRecommendedArrangements.size() > 20) {
        // Sort the arrangements by recommendation points in descending order.
        // If the recommendation points are equal, sort by date in descending order to favor newer arrangements.
        List<Arrangement> sortedArrangements = new ArrayList<>();

        for(Object arrangement : $isRecommendedArrangements){
            sortedArrangements.add((Arrangement) arrangement);
        }

        sortedArrangements.sort((arr1, arr2) -> {
            int comparison = Double.compare(arr2.getRecommendationPoints(), arr1.getRecommendationPoints());
            if (comparison == 0) {
                // If recommendation points are equal, sort by date in descending order
                return arr2.getDate().compareTo(arr1.getDate());
            }
            return comparison;
        });

        // Iterate through the sorted list and modify arrangements outside the top 20
        for (int i = 20; i < sortedArrangements.size(); i++) {
            Arrangement arrangement = sortedArrangements.get(i);
            if (arrangement != null) {
                modify(arrangement) {
                    setRecommended(false);
                }
            }
        }

    }
end